# 为什么废除永久代转成元空间？
这种设计导致了Java应用更容易遇到内存溢出的问题
（久代有-XX：MaxPermSize的上限，即􀖯不设置也有􅔈认大小，
而J9 JRockit只有触到进程可用内存的上限，如32位系统中的4GB限制，就不会出问题）
而且有极少数方法（如String::intern()）会因为永久代的原因而导致不同虚拟机下有不同的表现

# 对象的创建过程？
当Java虚拟机遇到到一条字节码new指令时
1. 检查指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用是否已经被加载、解析和初始化过
2. 虚拟机为新生对象分配内存（对象所需内存在类加载完成就可确定）
    内存分配策略
        - 内存绝对规整 - 指针碰撞  Serial、ParNew 带压缩整理过程的收集器
            并发情况下指针碰撞是不安全的行为，采用 CAS失败重试方式或则 TLAB（Thread local allocation buffer） -XX :+/-UseTLAB
        - 虚拟机必须维护一个列表记录内存使用情况，并找到足够大的内存空间划分出来  -  空闲列表
3. 虚拟机将分配到的内存空间(不包括对象头)初始化为零值
4. 对对象进行必要的设置：哪个类的实例、元数据信息、GC分代年龄
5. 构造函数执行

# 对象是如何访问定位？
- 句柄的方式，Java堆划分出一块内存作为句柄池，需要访问对象会通过句柄访问到
    优势：reference中存储的是稳定的句柄地址，对象被移动时只改变句柄中的指针
    劣势：访问需要经过一层间接访问，增加句柄内存消耗
- 直接指针访问，需要访问对象就直接是对象地址，不用多一次间接访问
    优势：速度块
    
# GC Root 包括哪些？
- 在虚拟机栈（栈帧中的本地变量表）中的引用的对象
- 在方法区中的类静态属性引用的对象
- 在方法区中常量引用的对象
- 本地方法栈中的JNI引用的对象
- Java虚拟机内部的引用
- 所有被同步锁持有的对象

# 对象不可达原理
HotSpot的解决方案
里，是用一组称为OopMap的数据结构来􄗮到这个
目的。一旦类加载动作完成的时候，HotSpot会把
对象内什么偏移量上是什么类型的数据计算出来

# 引用的分类
- 强引用 无论任何情况下，只要强引用关系还存在，垃圾手机集器永远不会回收掉被引用的对象
- 软引用 
    只被软引用关联着的对象，在系统将要发生内存
      存溢出异常前，会把这些对象列进回收范围之中进
      行第二次回收，如果这次回收还没有足够的内存，
      才会抛出内存存溢出异常
- 弱引用 当垃圾收集器开始工作，无论内存是否足够都会回收调被弱引用关联的对象
- 虚引用

# 如何判定对象不可达？
两次标记：如果没有GCROot引用链，进行一次标记，随后进行一次筛选(finalize()方法)

# 什么是分配担保？