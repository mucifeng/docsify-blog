## 缓存和数据库一致性
```java
public Object get(String key){
    Object o = cache.get(key); //1
    if(o == null){
        o = db.get(key); //2
        cache.set(key, o); //3
    }
    return o;
}

public void update(String key, Object o){
    db.update(key, o); //4
    cache.delete(key); //5   更新时删除缓存
}
```
### update()方法成功之后在运行代码5时宕机？
导致数据库与缓存中的数据不一致情况。修改顺序:先删除缓存，再更新数据库。只要存在更新缓存异常的情况都会
清空当前缓存，在get()方法时，同样是从数据库中读取数据写入缓存，保证数据库缓存一致性。
```java
public void update(String key, Object o){
    cache.delete(key); //6   更新时删除缓存
    db.update(key, o); //7
}
```
### 问题升级：高并发下，线程A运行到了代码7(还未写入数据库), 此时线程B运行了代码2、代码3。会造成数据库与缓存不一致？
考虑在运行get()和update()时，满足方法内部部分代码块是原子性就能解决当前问题。
由于是分布式应用：
1. 分布式锁：在get()和update()之间添加分布式锁，主要是保证update()执行的时候不允许其余有关Key的操作
```
缺点：
    1.代码复杂程度增加
    2.引入了不相关的组建，就必须要保证锁发生时网络通信相关的可用性
    3. 对于分布式锁的应用场景上，需要增加额外的资源
    4. 对于热点数据，每次请求都加锁，网络开销是有的
```
2. 队列：使用独立于分布式应用的队列，同一个key操作事件发送到队列中执行，如将代码6、7组成代码块做成消息事件发送，将cache.set()作为消息事件发送
```
缺点：
    1.读请求长时阻塞，由于加入了队列请求需要排队，增加了读时消耗时间
    2. 当读请求并发过高时，更新时会特别缓慢的情况发生
    3. 多服务器部署队列，增加资源消耗
    4. 热点数据会造成数据倾斜的情况
```
