# 全局配置

|  配置   | 说明  |
|  ----  | ----  |
| daemonize no  | 这个参数指定redis是否以后台进程方式启动，默认不是，生产环境可以改成yes，另外，Redis是单线程的。 |
| pidfile /var/run/redis.pid  | 当daemonize参数为yes时，后台进程方式启动后，redis会创建进程文件，这个参数是指定此文件的路径。 |  
|  port 6379  | redistcp 监听端口，客户端通过此端口与redis服务器交互。非集群模式下，redis只有这个监听端口  |
|  tcp-backlog 511  | 客户端连接队列值，这个值是socket里面listen函数的参数。如果服务器caps很高，需要把这个参数改大些。  |
|  bind 192.168.1.100 10.0.0.1  |  监听地址，默认是监听所有网卡，也可以指定监听一个或多个。多个的格式：bind 192.168.1.1 192.168.1.0 |
|  unixsocket /tmp/redis.sock  | 指定用来监听Unix套接字的路径，没有默认值， 所以在没有指定的情况下Redis不会监听Unix套接字  |
| timeout 0   | client空闲几秒后断开连接，0为将这个功能职位不可用  |
|  tcp-keepalive 0  | 如果非零，则设置SO_KEEPALIVE选项来向空闲连接的客户端发送ACK，由于以下两个原因这是很有用的：<br>1）能够检测无响应的客户端 <br>2）让该连接中间的网络设备知道这个连接还存活，<br>在Linux上，这个指定的值(单位：秒)就是发送ACK的时间间隔。<br>注意：要关闭这个连接需要两倍的这个时间值。在其他内核上这个时间间隔由内核配置决定，在其他内核上这个时间间隔由内核配置决定，这个选项的一个合理值是60秒|
| loglevel notice   |  默认是notice，包括debug,verbose ,notice , warning. |
|  logfile ""  |  log 文件指定，默认是空，打印到控制台，可指定路径,如/var/log/redis.log |
|  databases 16  | 设置数据库个数。默认数据库是 DB 0。可以通过select <dbid> (0 <= dbid <= 'databases' - 1 ）来为每个连接使用不同的数据库。 |

# 持久化

|  配置   | 说明  |
|  ----  | ----  |
|  save 900 1  | 基于snapshot机制，定期执行持久化存储，生成rdb文件<br>第一个参数指定多久（单位是秒）执行一次，第二个是在第一个参数指定的时间内执行多少次写操作才执行持久化操作 |
|  stop-writes-on-bgsave-error yes  | 保存失败，停止工作 <br>默认如果开启持久化(至少一条save指令)并且最新的后台保存失败，Redis将会停止接受写操作<br>这将使用户知道数据没有正确的持久化到硬盘，否则可能没人注意到并且造成一些灾难.<br>如果后台保存进程能重新开始工作，Redis将自动允许写操作,然而如果你已经部署了适当的Redis服务器和持久化的监控，你可能想关掉这个功能以便于即使是硬盘，权限等出问题了Redis也能够像平时一样正常工作 |
|  rdbcompression yes  | 当导出到 .rdb 数据库时是否用LZF压缩字符串对象  |
|  rdbchecksum yes  |  因为版本5的RDB有一个CRC64算法的校验和放在了文件的最后。这将使文件格式更加可靠但在生产和加载RDB文件时，这有一个性能消耗(大约10%)，所以你可以关掉它来获取最好的性能。生成的关闭校验的RDB文件有一个0的校验和，它将告诉加载代码跳过检查 |
|  dbfilename dump.rdb  | 持久化数据库的文件名  |
|    |   |
|    |   |