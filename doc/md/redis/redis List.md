## 一、Redis 中 list 的介绍

Redis 中的 list 是一种非常实用的数据结构，它本质上是一个字符串值的链表。这种链表结构通过双向链表实现，具有诸多特点和优势。

首先，即使列表内有大量元素，在头部或尾部添加新元素也能在恒定时间内完成。这意味着无论列表的长度如何增长，向其头部或尾部插入元素的操作效率始终保持在一个高效的水平，时间复杂度为 O (1)。

Redis 中的 list 限制长度为 2^32 - 1 个元素，这个巨大的长度限制使得它在大多数应用场景下都能满足存储需求。

同时，访问头部或尾部操作是 O (1)，能够快速地获取或移除列表的首尾元素。

然而，需要注意的是，操作列表中元素的命令通常是 O (n)，这意味着如果要在列表中间进行查找、插入或删除等操作，随着列表长度的增加，操作的时间成本会线性增长。

例如，使用 lindex 命令获取列表中指定位置的元素时，时间复杂度为 O (n)，因为列表本质是链表，所以当元素的个数多的时候，使用该命令效率比较慢。当后面的数字为负数时，表示为对应的倒数第几个，即 -1 表示倒数第一个。

从命令操作的角度来看，将值从左到右依次插入到列表中可以使用 lpush 命令，将值从右到左依次插入到列表中可以使用 rpush 命令。取第几个位置的值可以使用 lindex 命令，但要注意其时间复杂度。从左到右删除列表中的第一个元素使用 lpop 命令，从右到左删除列表中的第一个元素使用 rpop 命令。

当列表中的元素使用 lpop 或 rpop 全部删除之后，该列表也会自动被删除，内存会被回收。同理，使用 rpush 往列表中插入元素的过程与使用 lpush 插入元素的过程相反。另外，获取整个 list 中的指定区间的数据可以使用 lrange 命令，第一个数字代表起始位置，第二个数字代表结束的位置（数字为负数时，即表示的对应的倒数第几个）。如果使用 lpop 或 rpop 删除列表中的全部元素会比较麻烦，尤其当列表中的元素非常多的时候；这个时候可以使用 ltrim 删除列表中的全部元素，命令为：ltrim books 1 0（其中这个命令是保留的意思，第一个数字代表起始位置，第二个数字代表结束位置，即表示要保留的列表的区间，当第一个数字为 1，第二个数字为零时，这个区间为负，即为全部删除列表中的元素；也并不是只有 1，0 能全部删除列表中的元素，只要区间为负，都能删除，不过为了规范，还是用 1 和 0）。

Redis 的 list 还可以实现不同的数据结构应用。例如，rpush 和 lpop 的组合可以实现队列（右边进左边出），rpush 和 rpop 的组合可以实现栈（右边进右边出）。获取列表中元素的个数可以使用 llen 命令。

## 二、Redis list 的实现原理

### （一）版本 3.2 之前的实现

在 Redis 版本 3.2 之前，Redis 列表（list）的底层实现有两种数据结构，分别是压缩列表（ziplist）和双向链表（linkedlist）。

1. 使用压缩列表 ziplist 和双向链表 linkedlist 作为底层实现。创建新列表时默认使用压缩列表，当满足特定条件时会转换为双向链表。转换条件为：试图往列表新添加一个字符串值且长度超过 server.list_max_ziplist_value（默认值为 64）；ziplist 包含的节点超过 server.list_max_ziplist_entries（默认值为 512）。

- 创建新列表时，Redis 默认使用压缩列表（ziplist）作为存储结构。这是因为双向链表占用的内存比压缩列表要多。当创建新的列表键时，列表会优先考虑使用压缩列表，并且在有需要的时候，才从压缩列表实现转换到双向链表实现。

- 压缩列表转化成双向链表的条件是：当试图往列表新添加一个字符串值，且这个字符串的长度超过 server.list_max_ziplist_value（默认值为 64）；或者当 ziplist 包含的节点超过 server.list_max_ziplist_entries（默认值为 512）时，列表会被转换成 redis_encoding_linkedlist 编码，即使用双向链表作为底层实现。

### （二）版本 3.2 之后的实现

在 Redis 版本 3.2 之后，引入了 quicklist 作为列表的底层实现。

1. 引入 quicklist，列表的底层都由 quicklist 实现。quicklist 是一个 ziplist 组成的双向链表，每个节点使用 ziplist 来保存数据。既保证了少使用内存，也保证了性能。

- quicklist 是对 ziplist 进行一次封装，本质上是一个标准的双向链表，有 head 和 tail，每一个节点是一个 quicklistNode，包含 prev 和 next 指针以及一个 ziplist。

- quicklist 里面保存着一个一个小的 ziplist，每个 quicklistNode 包含一个 ziplist，*zp 压缩链表里存储键值。使用小块的 ziplist 既保证了少使用内存，也保证了性能。

### （三）ziplist 的结构与特点

1. ziplist 是一个特殊的双向链表，没有维护双向指针 prev 和 next，而是存储上一个 entry 的长度和当前 entry 的长度，通过长度推算下一个元素位置。

- ziplist 本质上就是一个字节数组，是 Redis 为了解决内存而设计的一种线性数据结构。它是一个特殊编码的双向链表，没有维护双向指针 prev 和 next，而是存储上一个 entry 的长度和当前 entry 的长度，通过长度推算下一个元素在什么地方。

- ziplist 中的每个元素都以包含两部分的元数据为前缀信息，首先，将前一个元素的长度存储为 previous entry length，能够实现从后到前遍历列表。其次，条目编码 encoding 是表示条目类型，整数或字符串，在 case 中它还表示字符串负载的长度。

- 每一个存储节点 zlentry，都包含 prevrawlen（前一个 entry 的长度）、lensize（当前 entry 的长度如何编码所需的字节大小）、len（当前节点长度）、headersize（当前节点的 header 大小）、encoding（节点的编码方式）、p（指向节点的指针）。完整的 zlentry 由以下三部分组成：prevrawlen：记录前一个节点所占有的内存字节数，通过该值，我们可以从当前节点计算前一个节点的地址，可以用来实现表尾向表头节点遍历；len/encoding：记录了当前节点 content 占有的内存字节数及其存储类型，用来解析 content 用；content：保存了当前节点的值。

2. 牺牲读取性能获得高效存储空间，字段、值比较小时才会用 ziplist。

- ziplist 牺牲读取的性能，获得高效的存储空间，因为（简短字符串的情况）存储指针比存储 entry 长度更费内存。这是典型的 “时间换空间”。

- ziplist 使用局限性在于：字段、值比较小，才会用 ziplist。当一个列表只有少量数据的时候，并且每个列表项要么是小整数值，要么就是长度比较短的字符串，那么 Redis 就会使用 ziplist 来做 List 的底层实现。

3. ziplist 存在连锁更新问题，最坏情况下时间复杂度为 O (N^2)，但引起性能问题的概率极低。

- ziplist 存在连锁更新问题。因为在 ziplist 中，每个 zlentry 都存储着前一个节点所占的字节数，而这个数值又是变长编码的。假设存在一个压缩列表，其包含 e1、e2、e3、e4……，e1 节点的大小为 253 字节，那么 e2.prevrawlen 的大小为 1 字节，如果此时在 e2 与 e1 之间插入了一个新节点 e_new，e_new 编码后的整体长度（包含 e1 的长度）为 254 字节，此时 e2.prevrawlen 就需要扩充为 5 字节；如果 e2 的整体长度变化又引起了 e3.prevrawlen 的存储长度变化，那么 e3 也需要扩…… 如此递归直到表尾节点或者某一个节点的 prevrawlen 本身长度可以容纳前一个节点的变化。其中每一次扩充都需要进行空间再分配操作。删除节点亦是如此，只要引起了操作节点之后的节点的 prevrawlen 的变化，都可能引起连锁更新。

- 连锁更新在最坏情况下需要进行 N 次空间再分配，而每次空间再分配的最坏时间复杂度为 O (N)，因此连锁更新的总体时间复杂度是 O (N^2)。即使涉及连锁更新的时间复杂度这么高，但它能引起的性能问题的概率是极低的：需要列表中存在大量的节点长度接近 254 的 zlentry。

### （四）quicklist 的结构与优势

1. quicklist 是对 ziplist 进行一次封装，使用小块的 ziplist 既保证内存使用少，也保证性能。

- quicklist 是由多个 ziplist 组成的双向链表，每个 ziplist 存储一定数量的元素。结合了 ziplist 和双向链表的优点，既节省空间，又提升了修改操作的性能。

- quicklist 作为一个链表结构，在它的数据结构中，定义了整个 quicklist 的头、尾指针，这样一来，可以通过 quicklist 的数据结构，来快速定位到 quicklist 的链表头和链表尾。

2. 本质上是一个标准的双向链表，有 head 和 tail，每一个节点是一个 quicklistNode，包含 prev 和 next 指针以及一个 ziplist。

- quicklistNode 结构包含 prev（指向上一个 quicklistNode）、next（指向下一个 quicklistNode）、zl（指向该节点对应的 ziplist 结构）、sz（ziplist 的字节大小）、count（ziplist 中的元素个数）、encoding（编码格式，原生字节数组或压缩存储）、container（存储方式）、recompress（数据是否被压缩）、attempted_compress（数据能否被压缩）、extra（预留的 bit 位）。

- quicklist 的结构包含 head（quicklist 的链表头）、tail（quicklist 的链表尾）、count（所有 ziplist 中的总元素个数）、len（quicklistNodes 的个数）、fill（用来指明每个 quicklistNode 中 ziplist 长度）、compress（两端各有 compress 个节点不压缩）、bookmark_count（内存重分配时的书签数量及数组，一般用不到）、bookmarks（quicklist 的书签数组）。


## 三、Redis list 的应用

### （一）作为栈和队列

Redis 的 list 可以作为栈和队列使用，具体如下：

1. 右边进左边出可作为队列，如 rpush 和 lpop 组合。例如，使用LPUSH创建名为 “queue” 的 key 并放入元素，使用LRANGE查看放入的元素，使用RPOP取出放入的元素，可以发现取出的顺序与放入的顺序相同（先进先出），其特性与 Java 中的队列一样。

2. 右边进右边出可作为栈，如 rpush 和 rpop 组合。例如，使用LPUSH创建名为 “stack” 的 key 并放入元素，使用LRANGE查看放入的元素，使用LPOP取出放入的元素，可以发现取出的顺序与放入的顺序相反（先进后出），其特性与 Java 中的栈一样。

### （二）慢操作注意事项

1. lindex相当于 Java 链表的get(int index)方法，需要对链表进行遍历，性能随参数index增大而变差。例如，使用rpush将一些元素放入列表中，然后使用lindex获取特定位置的元素时，随着列表长度的增加和index值的增大，获取元素的时间会明显变长。

2. ltrim两个参数定义区间内的值将被保留下来，适合实现定长链表。ltrim操作可以控制列表的长度，避免列表过长导致的性能问题。例如，可以使用ltrim来清理列表中的旧数据，只保留最近的一部分数据。

### （三）消息队列应用

1. 常用指令实现消息队列步骤：消息入队使用LPUSH，消息出队使用RPOP，队列为空时可使用BRPOP阻塞等待消息到来。在实际应用中，生产者可以使用LPUSH将消息插入到列表中，消费者使用RPOP从列表中取出消息。如果队列为空，消费者可以使用BRPOP进行阻塞等待，直到有新的消息到来。

2. 但这种方式实现的队列不安全，因为RPOP命令特性可能导致元素丢失，可使用RPOPLPUSH命令将元素从一个队列转移到另一个队列，提高安全性。具体操作是在 A 队列推出元素（并删除）时，保存元素到 B 队列。如果处理元素的客户端崩溃了，还可以在 B 队列找到。

3. 此方法存在问题，如多个消费者同时操作可能导致消息堆积，处理消息的客户端崩溃后可能出现问题，且 redis list 做消费者确认 ACK 麻烦，不能重复消费。多个消费者同时将消息转存入第二个队列时，第二队列会出现（已执行、未执行）消息堆积。另外，对于一致性要求高的场景，这种方式不太适用。

4. 对于一致性要求高的场景，建议使用 Redis 5 的 Stream 或者 RocketMQ。Redis Stream 和 RocketMQ 在设计理念、功能和用途上与 Redis list 有显著区别。Redis Stream 适合需要高性能、低延迟的场景，如实时数据处理和日志系统，支持消费者组、消息确认等机制。RocketMQ 是一个分布式消息中间件，具备更强的可靠性、持久化和分布式支持，适合大规模系统和企业级应用。

## 四、总结

1. Redis list 通过不同的底层实现方式在不同版本中不断优化性能和功能。

Redis 的列表（list）在不同版本中经历了多次优化。在版本 3.2 之前，底层实现有压缩列表（ziplist）和双向链表（linkedlist）两种数据结构，创建新列表时默认使用压缩列表，当满足特定条件时会转换为双向链表。在版本 3.2 之后，引入了 quicklist 作为列表的底层实现，它是一个 ziplist 组成的双向链表，既保证了少使用内存，也保证了性能。而在 Redis 6.0 中，引入了多线程 IO，虽然执行命令仍然是单线程，但多线程部分可以更好地处理网络数据的读写和协议解析，进一步提升了性能。

2. 在应用方面，既可以作为栈和队列使用，也可以用于实现消息队列，但在某些高一致性要求场景下有一定局限性。

Redis 的 list 可以作为栈和队列使用，通过不同的命令组合可以实现先进先出的队列和先进后出的栈。同时，Redis 的 list 也可以用于实现消息队列，常用指令实现消息队列的步骤包括消息入队使用 LPUSH，消息出队使用 RPOP，队列为空时可使用 BRPOP阻塞等待消息到来。但这种方式实现的队列不安全，可使用 RPOPLPUSH命令将元素从一个队列转移到另一个队列，提高安全性。然而，这种方法存在问题，如多个消费者同时操作可能导致消息堆积，处理消息的客户端崩溃后可能出现问题，且 redis list 做消费者确认 ACK 麻烦，不能重复消费。对于一致性要求高的场景，建议使用 Redis 5 的 Stream 或者 RocketMQ。Redis Stream 和 RocketMQ 在设计理念、功能和用途上与 Redis list 有显著区别。Redis Stream 适合需要高性能、低延迟的场景，如实时数据处理和日志系统，支持消费者组、消息确认等机制。RocketMQ 是一个分布式消息中间件，具备更强的可靠性、持久化和分布式支持，适合大规模系统和企业级应用。